title: Определяем язык текста страницы средствами браузера
category: JavaScript
tags: NLP, GreaseMonkey, awk


Как Вы думаете, где современный человек сталкивается с наибольшим количеством текстовой информации ? Безусловно мы как и в былые времена читаем книги (пусть и электронными), но всё же основное время препровождения - это веб-браузер. И тут есть из чего выбирать - кому-то нравится *Firefox*, кто-то предпочитает *Chrome*, порой встречаются и экстремофилы, обитающие в *IE*. В общем как говорится на вкус и цвет. Но какой бы из существующих браузеров мы не предпочитали - количество текста, которое нам необходимо переварить, к сожалению от этого не уменьшается :-). Для анализа текстовой информации существует отдельная наука - [NLP](http://en.wikipedia.org/wiki/Natural_language_processing){:rel="nofollow"}, ниже будет описана маленький [UserScript]({attach}languageflag.user.js) который позволит динамически [определять язык](http://en.wikipedia.org/wiki/Language_identification){:rel="nofollow"} фрагмента текста страницы (либо всей страницы), имеющий несколько интересных особенностей. Определение языка это одна из задач, которыми занимается [NLP](http://en.wikipedia.org/wiki/Natural_language_processing){:rel="nofollow"}. Некоторые особенности нашего приложения:

- Код написан на *JavaScript* - соответственно это должно работать во всех современных браузерах. Сейчас кроссбраузерность ограничена [Greasemonkey](http://www.greasespot.net/){:rel="nofollow"}. При желании расширить горизонты настоятельно рекомендуется начать [отсюда](http://wiki.greasespot.net/Cross-browser_userscripting){:rel="nofollow"}.

- Язык определяется на стороне браузера - никаких дополнительных запросов на сторонние серверы. Это будет работать даже там, где нет выхода в глобальную паутину.

Чтобы лучше понять, о чем речь, предлагаю начать с конца - установить и пощупать в деле. *Greasemonkey* на текущий момент отлично поддерживается в *Firefix* и *Chrome*. В обоих случаях необходимо установить в браузер расширение с одноименным названием. Начнём с *лиса* - в меню *Инструменты* -> *Дополнения*:

![FF screenshot]({attach}FF-GM-ADDON-INSTALL.png){:style="width:100%; border:1px solid #ddd;"}

Для активации только что установленного дополнения *Firefix* требует перезапуска, после чего вверху справа появится симпатичная мордашка обезьянки. Теперь можно поставить [фичу]({attach}languageflag.user.js), просто кликнув по указанной ссылке. В результате появится такое окошко:

![FF screenshot]({attach}FF-GM-LI-INSTALL.png){:style="width:100%; border:1px solid #ddd;"}

Идея *Greasemonkey* такая - все необходимое для работы скачивается один раз при установке в локальное хранилище. В нашем случае это набор *.js* и *.png*. Далее при загрузке в браузере каждой страницы, *Greasemonkey* проверит все установленные скрипты на предмет заинтересованности последних в содержимом текущего *url*. Определитель языка использует ```*``` и тем самым говорит, что хочет отрабатывать на любых *url*. При загрузке страницы в html документа делается небольшая инъекция, добавляющая маленькую полупрозрачную кнопочку справа внизу клиентской части для отображения веб-содержимого:

![FF screenshot]({attach}FF-PREVIEW-PAGE-LOADED.png){:style="width:100%; border:1px solid #ddd;"}

Всё что осталось - это выделить интересующий фрагмент текста на странице и нажать на кнопочке. Если сделать то же самое, но ничего не выделять - будет использован текст со всей страницы:

![FF screenshot]({attach}FF-PREVIEW-PAGE-LNG.png){:style="width:100%; border:1px solid #ddd;"}

Теперь по-быстрому провернём тоже самое, но из-под *Chrome*, *Инструменты* -> *Расширения* -> *Посмотреть галерею*. В отличие от *FF* в *Chrome* для активации *Greasemonkey* перезапуск не требуется:

![Chrome screenshot]({attach}Chrome-Install.png){:style="width:100%; border:1px solid #ddd;"}

![Chrome screenshot]({attach}Chrome-Install-LI.png){:style="width:100%; border:1px solid #ddd;"}

![Chrome screenshot]({attach}Chrome-PREVIEW-PAGE-LNG.png){:style="width:100%; border:1px solid #ddd;"}

![Chrome screenshot]({attach}Chrome-PREVIEW-PAGE-LOADED.png){:style="width:100%; border:1px solid #ddd;"}

Пожалуй, картинок достаточно. Теперь немножко опишем технические детали. Данный материал будет интересен не всем, поэтому все что дальше можно не читать если Вы не имеете отношения к *IT*.

В основе представленного выше алгоритма определения языка лежит понятие [N-gram](http://en.wikipedia.org/wiki/N-gram){:rel="nofollow"}, а если конкретнее - замечательная работа с открытым кодом под кодовым названием [Tika](http://tika.apache.org/){:rel="nofollow"}, которая написана на ... *Java*. Вы наверно уже слышали о том, что с *Java* у современных браузеров любовь как-то не получилась, поэтому задействован [порт](http://mazko.github.com/jsli/){:rel="nofollow"} этой самой  [Tika](http://tika.apache.org/){:rel="nofollow"}, который по идее полностью совместим по линии *ngram* - файлов. Дальше, как говорится, дело техники :)

На выходе после определения языка имеем двухбуквенное обозначение языка в формате [ISO 639](http://www.loc.gov/standards/iso639-2/php/code_list.php){:rel="nofollow"}. С одной стороны у каждой страны может быть несколько языков, у каждого языка может быть несколько стран - с другой, мы ведь знаем что например на украинском языке говорят украинцы, и у нас только один украинский флаг. В процессе поиска решения ассоциации языка и страны-флага был найден следующий довольно тщательно замаскированный бесплатный [ресурс](http://download.geonames.org/export/dump/countryInfo.txt){:rel="nofollow"}. В этом файле первый столбец - название страны в формате [ISO-3166](http://userpage.chemie.fu-berlin.de/diverse/doc/ISO_3166.html){:rel="nofollow"}, 16 - список языков в [ISO 639](http://www.loc.gov/standards/iso639-2/php/code_list.php){:rel="nofollow"}, на которых там говорят. Соглашусь, что выглядит жутковато, но красота нам не нужна - всю работу готов выполнить скрипт на [awk](http://ru.wikipedia.org/wiki/AWK){:rel="nofollow"}:

*lang2flag.sh*

	:::bash
	awk -F"\t" '{ \
	if(!match($0, "^#") && $16 \
	&& substr(tolower(ARGV[2]),8) == substr(tolower($16),1,2)) \
	arr[total++] = tolower($1); } \
	END { if (!total) print "!!! NOT FOUND " \
	substr(tolower(ARGV[2]),8); \
	else if (total==1) print arr[0]; \
	else { result = arr[0]; \
	for (i = 1; i < total; i++) \
	result = result ", " arr[i]; \
	print "!!! " substr(tolower(ARGV[2]),8) " -> " result; } }' \
	countryInfo.txt target=$1

Сохраним его как ```lang2flag```, как обычно ```chmod +x``` и запустим для трёх разных ситуаций:

	:::bash
	~$ ./lang2flag.sh uk
	ua
	~$ ./lang2flag.sh xx
	!!! NOT FOUND xx
	~$ ./lang2flag.sh de
	!!! de -> at, ch, de, li

В первом случае всё нормально - язык *uk* (украинский) -> страна *ua* (Украина). Во втором - такого языка пока в природе нет, ошибка. Третий случай - на немецком говорит несколько стран, все они перечислены через запятую.

Флаги взяты в свободном доступе по наводке [отсюда](http://habrahabr.ru/post/155271/){:rel="nofollow"}.

Чуть [позже]({filename}../../java/2013-01-21-apache-tika-as-is/2013-01-21-apache-tika-as-is.md) стоит описать процесс расширения списка поддерживаемых языков - для этой цели понадобится задействовать оригинальную [Tika](http://tika.apache.org/){:rel="nofollow"} на ```Java``` а также много текста.
