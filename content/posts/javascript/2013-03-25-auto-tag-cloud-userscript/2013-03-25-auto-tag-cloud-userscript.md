title: Автоматическое облако ключевых слов каждому браузеру
category: JavaScript
tags: NLP, GreaseMonkey, Stemming, Lucene, JFlex


> Странные это были книги. Речь в них шла о ртути и соли, о драконах и царях, но Сантьяго, как ни старался, не понимал ничего. И все же одна мысль, повторявшаяся во всех книгах, до него дошла: все на свете - это разные проявления одного и того же.
> 
> Из одной книги он узнал, что самые важные сведения об алхимии - это всего несколько строчек, выведенных на изумруде.
> 
> - Это называется "Изумрудная скрижаль", - сказал англичанин, гордый тем, что может чему-то научить своего спутника.
> 
> - Но для чего же тогда столько книг?
> 
> - Для того, чтобы понять эти несколько строчек, - отвечал англичанин не слишком уверенным тоном. 
> 
> ***Пауло Коэльо. Алхимик***

Не знаю существует ли *Изумрудная скрижаль* в природе, но вот понятие [ключевого слова](http://ru.wikipedia.org/wiki/%D0%9A%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5_%D1%81%D0%BB%D0%BE%D0%B2%D0%BE){:rel="nofollow"} в современном вебе явление достаточно распространенное и полезное. Хотя есть и маленькая проблемка - сейчас ключевые слова *всегда* отдаются сервером, что сразу накладывает целый ряд ограничений:

- Для автоматического построения качественного облака ключевых слов из текста страницы может потребоваться немало вычислительных ресурсов - это безусловно обрадует хостера но вместе с тем может больно ударить по карману вебмастера.

- Статическое облако ключевых слов сэкономит ресурсы хостинга, но в таком случае управлять процессом генерации ключевых слов может только вебмастер - посетитель сайта остаётся не при делах и ничего с этим поделать нельзя, даже если очень сильно захочется. И как быть, если контент изменится на стороне клиента посредством того же *JavaScript* ?

Исходя из вышесказанного и принимая во внимание, что без посетителей сайтов не будет работы у вебмастеров, можно попробовать шагнуть навстречу юзабилити и убить двух зайцев сразу - дать возможность Посетителю сайта самому генерировать облако ключевых слов средствами браузера. Как-то так:

![FF screenshot]({attach}AutoTagCloud-li.png){:style="width:100%; border:1px solid #ddd;"}

![FF screenshot]({attach}AutoTagCloud-ru.png){:style="width:100%; border:1px solid #ddd;"}

![FF screenshot]({attach}AutoTagCloud-AE.png){:style="width:100%; border:1px solid #ddd;"}

![FF screenshot]({attach}AutoTagCloud-rel.png){:style="width:100%; border:1px solid #ddd;"}

Имея облако ключевых слов, отсортированных по частоте встречаемости в тексте документа, можно предположить что в данном случае имеем дело с человеком, который крутится в бизнесе как-то завязанном с *Теорией Относительности*... Ну а если серъёзно и по-чесноку то ничто конечно же не возникает из ничего и никуда не исчезает - за основу тут взята эта [работа]({filename}../2013-01-18-universal-language-identifier-for-every-modern-browser/2013-01-18-universal-language-identifier-for-every-modern-browser.md), а сам *GreaseMonkey* [скрипт](http://mazko.github.io/jstaggregator/) (перерос в расширение для браузера) может **бесплатно** установить и заценить любой желающий.

###КАК ЭТО РАБОТАЕТ

Чистый *JavaScript* и никакой магии. Первым делом нужно извлечь текст из HTML страницы. Если пользователь выделил какой-то фрагмент, доступ к его содержимому можно получить через объект [Selection](https://developer.mozilla.org/en-US/docs/DOM/Selection){:rel="nofollow"}. Если ничего не выделено, можно извлечь содержимое с помощью [jQuery](http://jquery.com/){:rel="nofollow"}, предварительно почистив DOM от не несущих смысловой нагрузки тегов:

	:::css
	$("body").clone().find("script,noscript,style").remove().end().text();

Определяется [язык](http://mazko.github.com/jsli/) текста, отображается соответствующий флаг, текст расщепляется на слова, причём с помощью умного [Tokenizer](http://en.wikipedia.org/wiki/Tokenization){:rel="nofollow"} на [JFlex](http://jflex.de/){:rel="nofollow"} (маленький патч для генерации *JavaScript* вместо *Java*), умеющего распознавать *Url*, *email* и т.д. как отдельные неделимые токены. Алгоритм взят из [Lucene](/java/2012/10/15/lucene-real-world/).

Строится облако ключевых слов. Имея представление о языке текста, можно определять основу каждого слова, т.е. применить [сте́мминг](http://mazko.github.com/jssnowball/). Готовые ключевые слова сортируются и отображаются в отдельном ```<iframe/>```, чтобы css-стили сайтов не могли повлиять на GUI облака.

###ТРУДНОСТИ

*GreaseMonkey* спроектирован таким образом, что для каждого ```<iframe/>``` в пределах страницы скрипт срабатывает по отдельности. В принципе сайты, состоящие из нескольких ```<iframe/>``` встречаются довольно редко, но всё же они [есть](http://www.pumpkininc.com/){:rel="nofollow"}. На текущий момент в заложена следующая логика поведения (по крайне мере для FF):

- Если ```<iframe/>``` принадлежит другому домену, нежели сам сайт, пропускаем (скорее всего это какие-то кнопочки соц. сетей типа FB - их содержимое не интересно посетителю страницы)

- В противном случае смотрим, есть ли полезный текст - если такового нет, пропускаем. Ниже в качестве примера показан сайт, состоящий из 3 фремов, принадлежащих тому же домену, что и сам сайт. Верхний фрейм полезного текста не содержит - в противном случае в районе курсора стоило бы ожидать мордашку.

![FF screenshot]({attach}iframes-salvo.png){:style="width:100%; border:1px solid #ddd;"}

Если верить [уважаемым людям](http://wiki.greasespot.net/CSS_Independent_Content){:rel="nofollow"}, в ```<iframe/>``` часто могут быть косяки. Со временем в контексте текущей задачи альтернативой может стать техника под названием [Shadow DOM](http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/){:rel="nofollow"}. Поживём увидим.
