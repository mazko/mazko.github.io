title:  С++ для микроконтроллеров - управление памятью
category: Embedded 
tags: msp430, QP, UML


Как известно, в языке Си для динамического выделения и освобождения памяти на куче используются функции `malloc()` и `free()`. В С++ для этих целей предусмотрены операторы `new` и `delete`. Когда оператор `new` не может удовлетворить запрос на выделение памяти, он возбуждает исключение `std::bad_alloc`, сигнализируя тем самым об ошибке. В [C++ для микроконтроллеров]({filename}../2017-03-20-mcucpp-introduction/2017-03-20-mcucpp-introduction.md) механизм обработки исключений обычно отключён для экономии ресурсов, однако согласно спецификации С++, прежде чем возбудить исключение `std::bad_alloc`, оператор `new` вызывает специальную функцию-обработчик. Эту функцию можно переопределять `std::set_new_handler`, что позволяет хоть как-то контролировать / фиксировать ошибки выделения памяти на куче в процессе выполнения программы. Но это только верхушка айсберга, а ниже описаны более эффективные и надёжные приёмы. Чтобы было нескучно, в качестве тестового материала взята игра «Змейка».

[MSP430.js](http://mazko.github.io/MSP430.js/efadb63e855ca5799cc873ca38ebc2ad) | [исходники]({attach}snake-qv-msp430-js.zip)

[comment]: <> (byzanz-record --x=313 --y=131 -w 803 --delay 3 -d 55 ui.flv)
[comment]: <> (rm -rf frames/* && ffmpeg -i ui.flv -pix_fmt rgb24 -r 10 "frames/frame-%05d.png")
[comment]: <> (convert -monitor -limit memory 1024MiB -limit map 2048MiB -layers Optimize -layers removeDups -delay 10 -loop 0 "frames/*.png" ui.gif)

![screenshot]({attach}ui.gif){:style="width:55%; margin: 0 auto; display:block;"}

 - операторы `new` и `delete` в С++ можно перегружать, а в контексте микроконтроллеров может оказаться весьма полезным вообще сломать компиляцию при попытке динамического выделения памяти на куче [no-new.h]({attach}no-new.h). Для того, чтобы проверка происходила во всех исходных файлах проекта автоматически в gcc подобных компиляторах достаточно просто указать в командной строке опцию `-include no-new.h`, в случае со «Змейкой» используется IDE [Code Composer Studio](http://www.ti.com/tool/ccstudio-msp){:rel="nofollow"}, там есть настройка *--preinclude*. Что касается наследия Си — функций динамического выделения памяти `malloc`, `calloc`, `realloc` — то красиво отцепить их увы не получится. У gcc компиляторов есть волшебный флаг компоновщика `-Wl,--wrap=malloc`, который даёт возможность ставить обёртки на функции. Как это сделать на примере покажу чуть [позже]({filename}../2018-03-18-mcucpp-observer/2018-03-18-mcucpp-observer.md)

 - «Змейка» кушает и растёт, т.е. представляет из себя динамический массив. Для STL контейнеров в С++ можно задавать альтернативные аллокаторы памяти. В большинстве случаев разработчик знает, сколько элементов контейнера может потребоваться для его алгоритма и тогда хорошей идеей выглядит аллокатор, использующий стек вместо кучи. Для древнего C++98 найти рабочий аллокатор затруднительно, поэтому для игры «Змейка» был взят этот [контейнер](https://github.com/esrlabs/estl-teaser){:rel="nofollow"}, также использующий стек вместо кучи 

 - существует особая форма оператора `new`, называемая *Placement new*. Данный оператор не выделяет память, а получает своим аргументом адрес на уже выделенную каким-либо образом память. Например память под объект «Змейка» выделяется в стеке на этапе компиляции, а  размещение (инициализация) объекта в ней путём вызова конструктора происходит в процессе выполнения программы, таким образом можно пересоздавать «Змейку» при перезапуске игры

Под капотом «Змейки» [QP/C++]({filename}../../2017-05-25-msp430-qp/2017-05-25-msp430-qp.md) и соответствущая диаграмма состояний UML:

![screenshot]({attach}SMofSnakeAO.png){:style="width:100%; border:1px solid #ddd;"}

На картинке иерархический конечный автомат *Play* где отсчитываются временные интервалы для движения «Змейки» и обрабатывается нажатие от кнопок. Если метод `eat_or_move()` вернёт `false` переход в состояние *GameOver* где отображается количество набранных очков. При нажатии любой кнопки снова *Play*.

«Змейка» представляет из себя динамический массив сегментов (квадратиков), для её передвижения в заданном направлении достаточно добавить новый сегмент головы в один конец массива и удалить сегмент хвоста — последний элемент с другого конца. На экране аналогично достаточно очистить хвост и дорисовать голову. При поедании пищи добавляется сегмент головы, а сегмент хвоста не удаляется.

[Далее]({filename}../2018-03-18-mcucpp-observer/2018-03-18-mcucpp-observer.md) паттерн «Наблюдатель».
