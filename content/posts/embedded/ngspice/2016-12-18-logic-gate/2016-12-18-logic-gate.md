title: NGSPICE.js - логические вентили
category: Embedded 
tags: gEDA, ngspice, gate

[Продолжаем]({filename}../2016-10-28-ngspice-introduction/2016-10-28-ngspice-introduction.md) осваивать NGSPICE.

 Аналоговый сигнал изменяется непрерывно - аналогично физической величине и может принимать любые значения в любой момент времени. Дискретный сигнал имеет конечное число значений. Обычно цифровой сигнал может принимать только два дискретных значения 0 и 1 - например за ноль принимается уровень напряжения в пределах от 0 до 0,5 В, а всё что выше считается единицей. На этапе преобразования аналогового сигнала в цифровой физическая величина фиксируются только в определённые моменты времени и только в определённых пределах (ограниченных разрядностью) и в результате неизбежно происходит какая-то частичная потеря информации, однако цифровые сигналы на порядок лучше защищены от действия шумов, наводок и помех, ведь что 0.1 В, что 0.3 В это ведь всё тот же 0. Поведение цифровых устройств всегда можно абсолютно точно рассчитать и предсказать математически с помощью Булевой алгебры. В основе данной алгебраической системы лежат следующие функции: конъюнкция (логическое умножение, оператор «AND»), дизъюнкция (логическое сложение, оператор «OR») и отрицание (оператор «NOT»). Цифровые схемы, реализующие эти функции принято называть логическими вентилями.

 Подавляющее большинство современных логических микросхем, в том числе процессоров, используют КМОП (CMOS) технологию на [полевых]({filename}../2016-11-03-field-effect-transistor/2016-11-03-field-effect-transistor.md) транзисторах, т.к. она выгодно выделяется очень малым энергопотреблением на фоне других обитателей зоопарка (ТТЛ, ДТЛ, РТЛ, ЭСЛ и т.д.).

В следующих схемах для симуляции использовались SPICE модели комплементарных [MOSFET]({filename}../2016-11-03-field-effect-transistor/2016-11-03-field-effect-transistor.md) транзисторов: [p-канал]({attach}pMOSe.txt) | [n-канал]({attach}nMOSe.txt).

[КМОП вентили]({attach}logic-gate.sch) | [netlist]({attach}logic-gate.net) | [ngspice.js](https://ngspice.js.org/?gist=97f3ffa9bf4ef930231b1efb3fe04c58)

![screenshot]({attach}show-img-logic-gate.png){:style="width:100%; border:1px solid #ddd;"}

    :::text
    ngspice 1 -> source logic-gate.net
    ngspice 2 -> dc v2 0 3 3 v3 0 3 3
    ngspice 3 -> print in1 in2 nor
    ngspice 4 -> print ceil(max(in1-0.5,0)/2.5) ceil(max(in2-0.5,0)/2.5) ceil(max(nor-0.5,0)/2.5)
    ngspice 5 -> print in1 in2 nand
    ngspice 6 -> print ceil(max(in1-0.5,0)/2.5) ceil(max(in2-0.5,0)/2.5) ceil(max(nand-0.5,0)/2.5)

На схеме слева вентиль ИЛИ-НЕ, а рядом И-НЕ. Поскольку маломощные полевые транзисторы очень чувствительны к статистическому электричеству, на входах дополнительно ставят ограничительные диоды, которые на логику не влияют. Ещё если присмотреться, то очевидно [входное]({filename}../2016-11-09-bipolar-common-collector/2016-11-09-bipolar-common-collector.md) сопротивление транзистора Q7 > Q8 (ровно как и Q2 > Q1) и для симметрии подложку Q7(Q2) можно было бы соединить с подложкой Q8(Q1). Но с учётом очень большого входного сопротивления у полевых транзисторов в учебных целях асимметрией можно спокойно пренебречь. Таблица истинности:

    :::text
    ---------------------------------------------------------------------------------
    Index             in1                 in2                 nor                nand
    ---------------------------------------------------------------------------------
    0        0.000000e+00        0.000000e+00        1.000000e+00        1.000000e+00
    1        1.000000e+00        0.000000e+00        0.000000e+00        1.000000e+00
    2        0.000000e+00        1.000000e+00        0.000000e+00        1.000000e+00
    3        1.000000e+00        1.000000e+00        0.000000e+00        0.000000e+00

Вентили ИЛИ-НЕ, И-НЕ являются универсальными и взаимозаменяемыми - при наличии достаточного их количества можно синтезировать любую логику. Для дальнейших экспериментов удобно вынести каждый вентиль в отдельную подсхему SUBCKT.

*nand.lib*

    :::text
    .SUBCKT NAND IN1 IN2 OUT Vcc GND
    .model nMOSe nmos (vto=1)
    .model pMOSe pmos (vto=-1)
    MQ7 OUT IN1 2 2 nMOSe
    MQ8 2 IN2 GND GND nMOSe
    MQ6 OUT IN2 Vcc Vcc pMOSe
    MQ5 OUT IN1 Vcc Vcc pMOSe
    .ENDS NAND

*nor.lib*

    :::text
    .SUBCKT NOR IN1 IN2 OUT Vcc GND
    .model nMOSe nmos (vto=1)
    .model pMOSe pmos (vto=-1)
    MQ3 OUT IN2 GND GND nMOSe
    MQ4 OUT IN1 GND GND nMOSe
    MQ1 1 IN2 Vcc Vcc pMOSe
    MQ2 OUT IN1 1 1 pMOSe
    .ENDS NOR

<!-- 
<a href="{attach}nand42.sym"></a>
<a href="{attach}nor42.sym"></a>
<a href="{attach}nor.lib"></a>
<a href="{attach}nand.lib"></a>
-->

<!-- 
sudo cp nor42.sym nand42.sym /usr/share/gEDA/sym/local/
-->

Правила де Моргана в краткой форме - *отрицание конъюнкции есть дизъюнкция отрицаний, отрицание дизъюнкции есть конъюнкция отрицаний*.

[правила де Моргана]({attach}demorgan.sch) | [netlist]({attach}demorgan.net) | [ngspice.js](https://ngspice.js.org/?gist=03e138a7ac3b861e69b685358b862539)

![screenshot]({attach}show-img-demorgan.png){:style="width:100%; border:1px solid #ddd;"}

    :::text
    ngspice 1 -> source demorgan.net
    ngspice 2 -> dc v2 0 3 3 v3 0 3 3
    ngspice 3 -> print in1 in2 "or"
    ngspice 4 -> print ceil(max(in1-0.5,0)/2.5) ceil(max(in2-0.5,0)/2.5) ceil(max("or"-0.5,0)/2.5)
    ngspice 5 -> print in1 in2 "and"
    ngspice 6 -> print ceil(max(in1-0.5,0)/2.5) ceil(max(in2-0.5,0)/2.5) ceil(max("and"-0.5,0)/2.5)

Как ни странно таблица истинности подтверждает справедливость правил Моргана в действии:

    :::text
    ---------------------------------------------------------------------------------
    Index             in1                 in2                  or                 and
    ---------------------------------------------------------------------------------
    0        0.000000e+00        0.000000e+00        0.000000e+00        0.000000e+00
    1        1.000000e+00        0.000000e+00        1.000000e+00        0.000000e+00
    2        0.000000e+00        1.000000e+00        1.000000e+00        0.000000e+00
    3        1.000000e+00        1.000000e+00        1.000000e+00        1.000000e+00

Далее триггеры.